# SheerTalent

An iPhone application written in Swift that presents a browsable list of Hebrew songs, organized by track. This README outlines the project scope, technical recommendations (including storage, data modeling, and iOS-specific implementation), UI/UX considerations tailored for Hebrew/RTL, and a detailed, phased plan with Definitions of Done (DoD) to guide development from inception through launch.

---

## Table of Contents

1. [Project Overview](#project-overview)
2. [Features](#features)
3. [Technical Recommendations](#technical-recommendations)

   * [Storage & Data Modeling](#storage--data-modeling)
   * [Backend vs. Backend-less](#backend-vs-backend-less)
   * [iOS-Specific Implementation](#ios-specific-implementation)
   * [Audio Playback](#audio-playback)
4. [UI/UX Considerations](#uiux-considerations)
5. [Project Plan](#project-plan)

   * [Phase 1: Xcode Project Setup & Architecture](#phase-1-xcode-project-setup--architecture)
   * [Phase 2: Storage Provisioning & Data Modeling](#phase-2-storage-provisioning--data-modeling)
   * [Phase 3: Networking & Data Layer](#phase-3-networking--data-layer)
   * [Phase 4: SwiftUI Screens & Navigation](#phase-4-swiftui-screens--navigation)
   * [Phase 5: Audio Playback Integration](#phase-5-audio-playback-integration)
   * [Phase 6: UI/UX Polish & Accessibility](#phase-6-uiux-polish--accessibility)
   * [Phase 7: Testing & App Store Preparation](#phase-7-testing--app-store-preparation)

---

## Project Overview

We are building an iOS app in Swift that:

* **Displays** a list of Hebrew songs, each represented as a separate track with relevant metadata.
* **Streams/Downloads** individual tracks on demand.
* **Provides** an interface fully localized for Hebrew—including right-to-left (RTL) layout.
* **Offers** search, filtering by artist, album, or track name (all in Hebrew).
* **Ensures** scalability, security, and maintainability for future expansion.

This README lays out recommendations for where and how to store audio files and metadata, outlines the iOS-specific choices (SwiftUI, Combine, AVFoundation), addresses UI/UX for Hebrew, and breaks work down into clear phases with Definitions of Done.

---

## Features

1. **Track Listing**

   * Present song title (Hebrew), artist name, album title (if any), and track number.
   * Display album art (or placeholder) next to each track.

2. **Audio Streaming & Playback**

   * “Play” button to stream audio from remote storage.
   * Background playback with lock-screen controls.
   * Download option for offline listening (future enhancement).

3. **Search & Filtering**

   * Real-time search bar supporting Hebrew text.
   * Filters by artist and album (potentially genre or year later).

4. **Responsive RTL Layout**

   * All UI elements flow right-to-left.
   * Adaptive for all iPhone screen sizes (iPhone SE up to Pro Max).

5. **Settings & Preferences (Phase 6/7)**

   * Dark mode support (iOS system-wide).
   * Option to toggle “Autoplay Next Track.”

6. **Optional Admin Interface** (Phase 7+)

   * A simple web backend or admin-only iOS screen to upload new tracks and metadata.

---

## Technical Recommendations

### Storage & Data Modeling

#### 1. Audio Files

* **Recommendation**: Use **Firebase Storage** (or AWS S3 + custom backend)

  * Firebase Storage integrates seamlessly with iOS SDK, provides secure, scalable hosting, and auto-generates download URLs.
  * Alternatively, AWS S3 with a lightweight server (Node.js/Express or AWS Lambda) to generate presigned URLs.

* **File Structure in Storage** (example Firebase Storage paths):

  ```
  /tracks/
    /{artistID}/
       /{albumID}/
          - track01.mp3
          - track02.mp3
          - cover.jpg
  ```

* **Naming**:

  * Avoid special characters by using an internal slug (e.g., Base64 or transliterated Latin) for folder names, then store Hebrew title/artist as metadata in the database.

#### 2. Metadata

* **Recommendation**: Use **Cloud Firestore** (Firebase) or **PostgreSQL** if a custom backend is in place.

  * **Firestore** offers NoSQL flexibility, easy Swift client, and real-time listeners (for live updates).
  * **PostgreSQL** (hosted on Heroku or AWS RDS) + REST API if you prefer relational schema and strict typing.

* **Firestore Schema Example**:

  * `artists` collection

    * Document ID: `artist-slug` (e.g., “ben-kiba” or autogenerated UUID)
    * Fields:

      * `nameHebrew: String`
      * `nameEnglish: String?`
  * `albums` collection

    * Document ID: `album-slug`
    * Fields:

      * `titleHebrew: String`
      * `titleEnglish: String?`
      * `artistRef: Reference to artists/{artist-slug}`
      * `releaseYear: Int?`
      * `coverURL: String` (points to Firebase Storage path)
  * `tracks` collection

    * Document ID: autogenerated or `track-slug`
    * Fields:

      * `titleHebrew: String`
      * `titleEnglish: String?`
      * `artistRef: Reference to artists/{artist-slug}`
      * `albumRef: Reference to albums/{album-slug}`
      * `trackNumber: Int`
      * `audioURL: String` (Firebase Storage download URL or path)
      * `durationSeconds: Int?`
      * `lyrics: String?`
      * `createdAt: Timestamp`

* **Offline Caching**:

  * Firestore caches data locally by default; upon first launch, the user can browse seeded data until an online sync.
  * Audio files can be cached via `URLSessionDownloadTask` and stored under app’s Documents folder.

### Backend vs. Backend-less

* **Backend-less (Firebase)**

  * Pros:

    * Swift-native SDK, authentication (Firebase Auth), analytics, crash reporting.
    * Real-time updates if new songs are added.
    * Minimal server maintenance.
  * Cons:

    * Less control over complex relational queries.
    * Firestore costs can grow if reads/writes are heavy.

* **Custom Backend (Node.js + PostgreSQL + AWS S3)**

  * Pros:

    * Full control over schema, complex joins (e.g., “all tracks where trackNumber > 5 and releaseYear = 2020”).
    * Ability to add custom business logic (e.g., royalty tracking).
  * Cons:

    * Requires writing REST API, deploying/managing server, handling scaling, and writing presigned-URL logic.

* **Recommendation**: Unless there is a strong requirement for relational integrity or custom business logic, choose **Firebase Firestore + Firebase Storage** to minimize initial overhead. If, later, you outgrow Firestore, you can migrate to a custom backend.

### iOS-Specific Implementation

1. **Language & Framework**

   * **Swift 5.7+**
   * **SwiftUI** (iOS 15+) for declarative UI and built-in RTL support.
   * **Combine** for reactive data flows (observing Firestore publishers, handling asynchronous tasks).

2. **Project Structure**

   ```
   /HebrewSongsApp/
     ├── HebrewSongsAppApp.swift           # @main entry point
     ├── AppConfig/                        # Environment settings, service locators
     │    └── FirebaseManager.swift        # Initialize Firebase, handle auth if needed
     ├── Models/                           # Codable structs or ObservableObjects
     │    ├── Artist.swift  
     │    ├── Album.swift  
     │    └── Track.swift  
     ├── ViewModels/                       # ObservableObject classes
     │    ├── ArtistListViewModel.swift  
     │    ├── AlbumListViewModel.swift  
     │    └── TrackListViewModel.swift  
     ├── Views/                            # SwiftUI views
     │    ├── TrackListView.swift  
     │    ├── TrackRowView.swift  
     │    ├── TrackDetailView.swift  
     │    ├── PlayerView.swift  
     │    └── SearchBarView.swift  
     ├── Services/                         # Networking, Firestore & Storage wrappers
     │    ├── FirestoreService.swift  
     │    ├── StorageService.swift  
     │    └── AudioCacheService.swift  
     ├── Utilities/                        # Helpers (e.g., RTL adjustments, DateFormatters)
     │    ├── LocalizedString.swift  
     │    └── RTLModifier.swift  
     └── Resources/                        # Assets (AppIcon, LaunchScreen.storyboard, etc.)
   ```

3. **Swift Package Dependencies**

   * **FirebaseFirestoreSwift** (for Firestore Codable support)
   * **FirebaseStorage** (for audio file hosting)
   * **AVFoundation** (bundled in iOS, for audio playback)
   * (Optional) **Kingfisher** or **SDWebImageSwiftUI** for remote image caching (album art)

4. **Environment Configuration**

   * Use `GoogleService-Info.plist` (Firebase) in the project.
   * In `AppConfig/FirebaseManager.swift`, configure:

     ```swift
     import FirebaseCore

     final class FirebaseManager {
         static let shared = FirebaseManager()
         private init() {
             FirebaseApp.configure()
         }
     }
     ```
   * For custom backend, store base URL in `Info.plist` or a Swift `enum Environment`.

### Audio Playback

1. **Framework**: Use **AVPlayer / AVAudioPlayer** from **AVFoundation**.

   * **Streaming**:

     * Use `AVPlayer` to play from a remote URL (Firebase Storage download URL).
     * Example:

       ```swift
       import AVFoundation

       class AudioPlayer: ObservableObject {
           static let shared = AudioPlayer()
           private var player: AVPlayer?

           func play(from url: URL) {
               player = AVPlayer(url: url)
               player?.play()
           }

           func pause() {
               player?.pause()
           }

           // Observe current time, status changes, etc.
       }
       ```
   * **Offline Download** (Phase 5+):

     * Use `URLSessionDownloadTask` to save `.mp3` to local file, then play via `AVAudioPlayer(contentsOf: localURL)`.
     * Store downloaded files in `FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)`.

2. **Background Playback**

   * Update `Info.plist` with `UIBackgroundModes = audio`.
   * Configure `AVAudioSession.sharedInstance().setCategory(.playback)` so audio continues if the app goes to background.
   * Implement remote control center commands (play/pause/skip).

---

## UI/UX Considerations

1. **Right-to-Left (RTL) Layout**

   * SwiftUI respects the device language setting. If the user’s locale is Hebrew, `Text` views and layout direction will automatically mirror horizontally.
   * For custom flips (e.g., chevrons, play icons), wrap in:

     ```swift
     .environment(\.layoutDirection, .rightToLeft)
     ```
   * Ensure `TextAlignment` is `.trailing` for multi-line labels.

2. **Typography & Language**

   * Use a Hebrew-friendly font (e.g., system font supports “Alef”).
   * Base text size: 17 pt for body, scale for headings (e.g., 28 pt for large titles).
   * Line spacing ≥ 1.5 for readability of Hebrew lyrics.

3. **Color Palette**

   * Primary: Deep Blue (#005F94) for navigation bars or action buttons.
   * Secondary: Warm Orange (#E06F26) for accent (e.g., progress slider).
   * Background: White (#FFFFFF) or system background.
   * Text: Dark Gray (#212121).
   * Ensure contrast ratio ≥ 4.5:1.

4. **Navigation Flow**

   * **Tab Bar** (Phase 6+): two tabs: “שירים” (Songs) and “אתה” (Settings)
   * **List → Detail**:

     1. **TrackListView**: vertical list of `TrackRowView` items.
     2. Tapping a row pushes **TrackDetailView**, showing album art, full metadata, lyrics, and a “Play” button.

5. **Search**

   * Place a search bar at the top of `TrackListView`.
   * As user types, debounce 300 ms, then query Firestore for `titleHebrew >= query && titleHebrew < query + "\u{f8ff}"` to get prefix matches.
   * Show suggestions in a `List` beneath the search field (max 5 suggestions).

6. **Loading & Empty States**

   * While fetching from Firestore, show a `ProgressView()`.
   * If no tracks match, display a centered “לא נמצאו תוצאות” with an icon.

7. **Accessibility**

   * Label all buttons in Hebrew (e.g., `.accessibilityLabel("נגן שיר")`).
   * Support Dynamic Type by avoiding fixed `font(_:)` sizes; instead, use `.font(.body)`, `.font(.title2)`, etc.
   * Ensure tappable targets ≥ 44×44 pts.

---

## Project Plan

Below is a detailed, phased plan. Each phase has a clear Definition of Done (DoD) so that progress can be tracked objectively.

---

### Phase 1: Xcode Project Setup & Architecture

**Goals:**

* Create the iOS project skeleton in Swift & SwiftUI, configure CocoaPods/SwiftPM, and establish basic app flow.

**Tasks:**

1. **Initialize Xcode Project**

   * Create a new “App” target (iOS, Swift, SwiftUI).
   * Add `Bundle Identifier` (e.g., `com.company.HebrewSongsApp`).
   * Ensure deployment target is set to iOS 15.0+ for native SwiftUI features.

2. **Package Manager**

   * Integrate **Swift Package Manager** or **CocoaPods** to include:

     * `FirebaseFirestoreSwift`, `FirebaseFirestore`, `FirebaseStorage`, `FirebaseAuth` (if authentication).
     * `Kingfisher` (for remote image caching).

3. **Scene & App Entry**

   * In `HebrewSongsAppApp.swift`, initialize Firebase in the `init()` method:

     ```swift
     import SwiftUI
     import FirebaseCore

     @main
     struct HebrewSongsAppApp: App {
         init() {
             FirebaseApp.configure()
         }

         var body: some Scene {
             WindowGroup {
                 ContentView()
                     .environment(\.layoutDirection, .rightToLeft)
             }
         }
     }
     ```

4. **Basic ContentView Placeholder**

   * Create `ContentView.swift` that shows “ברוכים הבאים לאפליקציית שירים” centered.
   * Test on simulator: confirm RTL layout (text aligned to right).

5. **Project Architecture Document**

   * Add a brief markdown file `ARCHITECTURE.md` (optional) describing folder structure and core components.

6. **Version Control**

   * Commit initial project to Git.
   * Create `.gitignore` for Xcode-generated files (e.g., `Pods/`, `*.xcworkspace`, `DerivedData`).

**Definition of Done (DoD)**

* An Xcode project exists, compiles successfully, and runs in the simulator showing the “Welcome” placeholder in Hebrew.
* Firebase dependencies are installed and importable without errors.
* SwiftUI’s environment is set to RTL.
* Project structure (folders and example files) matches the recommended layout.
* Initial commit pushed to version control.

---

### Phase 2: Storage Provisioning & Data Modeling

**Goals:**

* Provision Firebase project (Firestore + Storage) and design the metadata schema.
* Seed sample data, upload placeholder audio files, and verify connectivity from a simple Swift playground or test ViewModel.

**Tasks:**

1. **Firebase Project Creation**

   * In Firebase Console, create new project “Hebrew Songs App.”
   * Enable **Cloud Firestore** in production mode.
   * Enable **Firebase Storage**.

2. **Firestore Data Model**

   * Define collections and example documents:

     * `artists/{artist-slug}`
     * `albums/{album-slug}`
     * `tracks/{track-slug}`
   * In Firestore Console, manually create sample documents:

     ```jsonc
     // artists/ben-kiba
     {
       nameHebrew: "בן קיבה",
       nameEnglish: "Ben Kiba"
     }

     // albums/ben-kiba-laHityatim
     {
       titleHebrew: "הלהיטים שלו",
       artistRef: "artists/ben-kiba",
       releaseYear: 2020,
       coverURL: "https://firebasestorage.googleapis.com/v0/b/.../cover.jpg"
     }

     // tracks/track01
     {
       titleHebrew: "אהבה ישנה",
       artistRef: "artists/ben-kiba",
       albumRef: "albums/ben-kiba-laHityatim",
       trackNumber: 1,
       audioURL: "https://firebasestorage.googleapis.com/v0/b/.../track01.mp3",
       durationSeconds: 215,
       lyrics: "לראות את האהבה הישנה..."
     }
     ```

3. **Upload Placeholder Audio & Cover Art**

   * In Firebase Storage console, create folder `/tracks/ben-kiba/laHityatim/`.
   * Upload small dummy MP3 (5–10 seconds) as `track01.mp3`, plus an image `cover.jpg`.
   * Confirm public read rules (or set Storage security rules to allow read for all).

4. **Swift Model Types**

   * In `Models/Artist.swift`:

     ```swift
     import FirebaseFirestoreSwift

     struct Artist: Codable, Identifiable {
         @DocumentID var id: String?
         let nameHebrew: String
         let nameEnglish: String?
     }
     ```
   * In `Models/Album.swift`:

     ```swift
     import FirebaseFirestoreSwift

     struct Album: Codable, Identifiable {
         @DocumentID var id: String?
         let titleHebrew: String
         let titleEnglish: String?
         let artistRef: DocumentReference
         let releaseYear: Int?
         let coverURL: String
     }
     ```
   * In `Models/Track.swift`:

     ```swift
     import FirebaseFirestoreSwift

     struct Track: Codable, Identifiable {
         @DocumentID var id: String?
         let titleHebrew: String
         let titleEnglish: String?
         let artistRef: DocumentReference
         let albumRef: DocumentReference
         let trackNumber: Int
         let audioURL: String
         let durationSeconds: Int?
         let lyrics: String?
         let createdAt: Timestamp?
     }
     ```

5. **Initial Connectivity Test**

   * Create a `FirestoreService.swift` that can fetch all `tracks` once:

     ```swift
     import FirebaseFirestore
     import FirebaseFirestoreSwift
     import Combine

     final class FirestoreService {
         private let db = Firestore.firestore()

         func fetchAllTracks() -> AnyPublisher<[Track], Error> {
             db.collection("tracks")
               .order(by: "trackNumber")
               .limit(to: 10)
               .publisher()
               .eraseToAnyPublisher()
         }
     }
     ```
   * In a temporary SwiftUI `TestView`, subscribe to `fetchAllTracks()` and log results to console.
   * Verify sample data is returned.

**Definition of Done (DoD)**

* Firebase project exists with Firestore and Storage enabled.
* Sample artist, album, and track documents are present in Firestore.
* Placeholder audio and cover files are in Firebase Storage with public read access.
* Swift model structs (`Artist`, `Album`, `Track`) compile without errors.
* A basic Firestore fetch in a test view returns the sample tracks.

---

### Phase 3: Networking & Data Layer

**Goals:**

* Implement a robust data layer that handles CRUD operations for artists, albums, and tracks.
* Provide Combine-based publishers for use by ViewModels.

**Tasks:**

1. **FirestoreService Enhancements**

   * Methods to:

     * Fetch all artists (`fetchArtists()`)
     * Fetch albums by artist (`fetchAlbums(for artistID: String)`)
     * Fetch tracks by album (`fetchTracks(for albumID: String)`)
     * Search tracks by title or artist name (`searchTracks(query: String)`)
   * Use `.whereField(...)` and `.order(by: ...)` Firestore queries.
   * Return `AnyPublisher<[Model], Error>` for each.

2. **StorageService for Audio & Cover Art**

   * Methods:

     * `downloadCoverImage(from url: String) -> AnyPublisher<UIImage, Error>` (can use `URLSession.dataTaskPublisher`).
     * `getAudioDownloadURL(for path: String) -> URL` (simply parse the `audioURL` string).
     * (Phase 5+) `downloadAudioFile(from url: String) -> AnyPublisher<URL, Error>` to save locally.

3. **ViewModels**

   * **ArtistListViewModel**

     * `@Published var artists: [Artist] = []`
     * `func loadArtists() { ... }`
   * **AlbumListViewModel**

     * `@Published var albums: [Album] = []`
     * `func loadAlbums(artistID: String) { ... }`
   * **TrackListViewModel**

     * `@Published var tracks: [Track] = []`
     * `@Published var isLoading: Bool = false`
     * `func loadTracks(albumID: String?) { ... }`
     * `func searchTracks(query: String) { ... }`

4. **Error Handling**

   * Define a custom `AppError: LocalizedError` enum to wrap Firestore/Network errors.
   * In ViewModels, convert errors to user-friendly messages (Hebrew).

5. **Dependency Injection**

   * Use a simple service locator or constructor injection so that unit tests can provide mock services.
   * Example:

     ```swift
     class TrackListViewModel: ObservableObject {
         @Published var tracks: [Track] = []
         private let firestore: FirestoreServiceProtocol

         init(firestore: FirestoreServiceProtocol = FirestoreService.shared) {
             self.firestore = firestore
             loadTracks()
         }
         // ...
     }
     ```

6. **Unit Tests for Services**

   * Write mock versions of `FirestoreServiceProtocol` for unit testing.
   * Verify that `TrackListViewModel` populates `tracks` correctly when `fetchTracks` emits values.

**Definition of Done (DoD)**

* `FirestoreService` and `StorageService` implement all required methods, compile successfully, and are covered by unit tests.
* ViewModels (`ArtistList`, `AlbumList`, `TrackList`) can fetch data and update published properties.
* Sample UI (e.g., list in a `TestView`) can display artist, album, and track names.
* Errors are handled and surfaced in Hebrew messages.

---

### Phase 4: SwiftUI Screens & Navigation

**Goals:**

* Implement the core SwiftUI views: track list, track row, track detail, search bar, and navigation flow.

**Tasks:**

1. **TrackRowView**

   * Displays:

     * Album art thumbnail (fetched via `StorageService`).
     * Title (`Text(track.titleHebrew)`) with `.font(.headline)`, aligned to the right.
     * Artist name below in smaller font.
     * `Button` with play icon (use SF Symbol “play.circle.fill”).
   * RTL: Ensure container `HStack` has `alignment: .trailing`, and elements order is reversed compared to LTR (play icon on leftmost side, text flows right).

2. **TrackListView**

   * Embed `NavigationView` (automatically flips for RTL).
   * At top, include `SearchBarView` (bound to `TrackListViewModel.searchQuery`).
   * Below, a `List(tracks) { track in TrackRowView(track: track) }`.
   * OnAppear, call `viewModel.loadTracks()`.
   * Show `ProgressView()` when `viewModel.isLoading == true`.
   * If `tracks.isEmpty && !isLoading`, show a “אין תוצאות” message.

3. **TrackDetailView**

   * Shows large album art (e.g., 300×300 px) at top.
   * Title, artist, album, release year, and lyrics in a scrollable `ScrollView`.
   * “Play/Pause” button that invokes `AudioPlayer.shared.play(from: URL)`.
   * Progress slider (bind to `AudioPlayer`’s current time) and time elapsed / total time labels.

4. **SearchBarView**

   * `TextField` with placeholder “חפש שיר או אמן”.
   * On text change, debounce for 300 ms (use Combine’s `.debounce`) and call `viewModel.searchTracks(query:)`.
   * Below the field, show a small `List` of suggestions (use `viewModel.suggestions: [Track]`).
   * Tapping suggestion navigates to `TrackDetailView(trackID:)`.

5. **Main Navigation**

   * Use a `NavigationStack` (iOS 16+) or `NavigationView` with `NavigationLink`:

     ```swift
     NavigationView {
       TrackListView()
         .navigationTitle("שירים בעברית")
     }
     .environment(\.layoutDirection, .rightToLeft)
     ```
   * Push to `TrackDetailView` when a row is tapped.

6. **Assets & Icons**

   * Add app icon assets (`AppIcon` in Asset Catalog) sized for iPhone.
   * Use SF Symbols for play/pause (e.g., “play.fill”, “pause.fill”) with appropriate `.flipsForRightToLeftLayoutDirection(true)` to mirror icons.

7. **RTL Verification**

   * Run on Hebrew-language simulator; confirm all text is right-aligned, navigation bars display “Back” arrow on the right side, etc.

**Definition of Done (DoD)**

* `TrackRowView`, `TrackListView`, and `TrackDetailView` are implemented, compile, and display correctly in the simulator.
* Navigation from list → detail works and is fully RTL.
* Search bar shows suggestions and navigates to details.
* Album art and metadata render in Hebrew.
* No hardcoded LTR paddings/margins; all layouts adapt to RTL.

---

### Phase 5: Audio Playback Integration

**Goals:**

* Integrate full audio playback: streaming via `AVPlayer`, background audio, lock-screen controls, and (optional) offline download.

**Tasks:**

1. **AudioPlayer Singleton**

   * Implement `AudioPlayer.swift` as an `ObservableObject`:

     * `@Published var isPlaying: Bool`
     * `@Published var currentTime: Double`
     * `@Published var duration: Double`
     * Methods: `play(url: URL)`, `pause()`, `seek(to:)`.
   * Observe `AVPlayer`’s `timeControlStatus`, `currentItem.timeRange`, and `currentItem.duration` to update published properties.

2. **Background Modes & Lock-Screen Controls**

   * In `Info.plist`, add `UIBackgroundModes` with `audio`.
   * In `AppDelegate` (or SwiftUI `@main`), set up `AVAudioSession`:

     ```swift
     import AVFoundation

     do {
         try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default, options: [])
         try AVAudioSession.sharedInstance().setActive(true)
     } catch {
         print("Failed to configure audio session: \(error)")
     }
     ```
   * Configure `MPNowPlayingInfoCenter.current()` to display track info (title, artist, album art).
   * Handle remote commands via `MPRemoteCommandCenter`.

3. **Download for Offline (Optional in Phase 5)**

   * In `AudioCacheService.swift`, implement:

     * Check if file exists locally.
     * If not, use `URLSession.shared.downloadTask` to fetch and save to Documents.
     * On success, return local file URL.
     * On failure, surface an error to user.

4. **PlayerView UI**

   * At bottom of `TrackDetailView` or as a sticky overlay, show `PlayerView`:

     * Play/Pause button, progress slider, elapsed/remaining time.
     * For RTL: slider is mirrored automatically; time labels align to the left (elapsed on right, remaining on left).
   * Subscribe to `AudioPlayer.shared` to reflect current playback state.

5. **Error Handling**

   * If streaming fails (e.g., network issue), show an alert: “אין אפשרות להשמיע כעת, בדוק את החיבור.”

6. **Unit & Integration Tests**

   * Write tests for `AudioPlayer` (simulate a local file playback).
   * Verify progress updates, play/pause state toggling.

**Definition of Done (DoD)**

* Tapping “Play” on a track streams audio via URL, and audio begins immediately.
* Background playback works (lock screen shows track info; play/pause responds).
* Progress slider reflects current time and can seek within the track.
* If offline download is implemented: user can download a track, then play it offline.
* Errors in playback (e.g., invalid URL) are handled gracefully.

---

### Phase 6: UI/UX Polish & Accessibility

**Goals:**

* Refine the user interface, ensure high accessibility, implement dark mode, and add user preferences.

**Tasks:**

1. **Dark Mode Support**

   * Use `.preferredColorScheme(.light)` or `.dark` dynamically.
   * In SwiftUI, reference `Color.primary`, `Color.secondary` so system adapts.
   * Add a toggle in “Settings” to override system default. Store preference in `UserDefaults`.

2. **Advanced Search & Filters**

   * Add a “Filters” button in `TrackListView` navigation bar.
   * Present a modal sheet with filter options:

     * **Artist**: multi-select list of artists (with checkboxes).
     * **Album**: drop-down of albums.
     * **Release Year**: range slider.
   * Apply selected filters to Firestore query (e.g., `.whereField("artistRef", isEqualTo: artistDocRef)`).
   * Update `TrackListViewModel` to accept filter parameters.

3. **Accordion for Lyrics**

   * In `TrackDetailView`, display lyrics in a collapsible `DisclosureGroup` labeled “מילים”.
   * Default collapsed; user taps to expand if they want to read lyrics.

4. **Accessibility & VoiceOver**

   * Add `.accessibilityLabel` and `.accessibilityHint` to all tappable buttons.
   * For images (album art), add `.accessibilityLabel("עטיפת האלבום עבור \(track.titleHebrew)")`.
   * Test with VoiceOver on simulator, ensure labels read in Hebrew.

5. **Animations & Transitions**

   * Use `withAnimation` to fade in track cards on load (`.opacity` from 0→1).
   * Animate filter modal sheet presentation (`.transition(.move(edge: .trailing))`).
   * Smooth slider thumb movement (default SwiftUI animation is fine).

6. **Settings Screen**

   * Create `SettingsView` reachable from a “Settings” icon in navigation bar.
   * Options:

     * Toggle “אפליי אוטומטי לשיר הבא” (Autoplay next track).
     * Toggle “שמור שירים להאזנה לא מקוונת” (Prompt user to download when on Wi-Fi).
     * Switch for Dark Mode override.
   * Persist each setting in `UserDefaults` under keys like `isAutoplayEnabled`.

7. **Performance Optimization**

   * Lazy load album art via Kingfisher’s `.resizable().scaledToFit()` so images load asynchronously.
   * For long lists, use `LazyVStack` inside a `ScrollView` instead of a simple `List` if custom row interactions degrade performance.

8. **Accessibility Audit**

   * Run the Accessibility Inspector to check:

     * Dynamic Type compatibility (test fonts at 200%).
     * Hit-target sizes (all buttons ≥ 44×44 pts).
   * Address any color-contrast warnings (e.g., avoid light gray text on white).

**Definition of Done (DoD)**

* Dark mode visually coherent and persists user’s choice across launches.
* Filter sheet filters tracks correctly; selections persist until reset.
* Lyrics accordion expands/collapses with smooth animation.
* All UI elements have proper accessibility labels; VoiceOver reads Hebrew labels correctly.
* Animations do not stutter; scrolling remains smooth on older devices (e.g., iPhone 8).
* No critical accessibility audit issues remain.

---

### Phase 7: Testing & App Store Preparation

**Goals:**

* Thoroughly test the app (unit, UI, and beta testing), configure App Store metadata, and submit to App Store.

**Tasks:**

1. **Unit Tests**

   * Test ViewModels: verify filtering logic, search query behavior.
   * Test `AudioPlayer` methods: play, pause, seek.
   * Test `StorageService` and `FirestoreService` using mock Firestore and Storage (Firebase provides local emulator suites).

2. **UI Tests (XCTest UI Testing)**

   * Record test flows for:

     * Launch app → view track list → tap first track → play.
     * Search for “אהבה” → verify filtered results.
     * Open filters → select an artist → confirm filtered list.
   * Ensure tests pass in both light and dark mode.

3. **Beta Testing (TestFlight)**

   * Create an App Store Connect record.
   * Archive and upload build.
   * Invite internal testers (team) for feedback.
   * Address any crash reports or user complaints before proceeding to production.

4. **App Store Metadata & Screenshots**

   * Write App Name (e.g., “שירים בעברית – Hebrew Songs”).
   * Prepare App Icon (iOS guidelines) and two sets of screenshots (iPhone 14 and iPhone 14 Pro Max) in both light/dark mode.
   * App description in Hebrew:

     > “האפליקציה הרשמית לשירים בעברית. גלשו בין כל השירים, שמעו ישירות מהשרת, שמרו להאזנה לא מקוונת, וכל זאת בממשק ברור ולטובת קריאה מימין לשמאל.”
   * Add keywords: “שירים”, “מוזיקה”, “עברית”, “Hebrew Music”.

5. **Final Smoke Test on Production**

   * After App Store approval, install from App Store.
   * Perform a final end-to-end check:

     * Open app, search, play, background audio, lock-screen controls, filters.
     * On poor network (e.g., airplane mode), confirm offline track download works.

6. **Push Notification Setup (Optional Future)**

   * If sending new-song alerts, integrate **Firebase Cloud Messaging** (FCM) and request user permission.

**Definition of Done (DoD)**

* Unit tests achieve ≥ 85% coverage; all tests pass.
* UI tests pass on at least two device families (e.g., iPhone 12, iPhone 8).
* Beta testers confirm no major crashes or UX blockers.
* App Store listing is complete with Hebrew description, keywords, and localized screenshots.
* Production version is live on the App Store, and user reviews (first 24 h) have no critical complaints (≥ 4-star average).

---

## Next Steps

1. **Review & Adjust**

   * Review this README with stakeholders (designers, backend engineers) to confirm storage choices and architecture.
   * Adjust Firestore rules or backend endpoints if needed.

2. **Issue Tracking**

   * Create tickets in your issue tracker (GitHub Issues, Jira) corresponding to each task above.
   * Assign priorities and owners.

3. **Begin Phase 1**

   * Start by setting up the Xcode project and confirming the RTL SwiftUI placeholder.

4. **Continuous Review**

   * After each phase, revisit this README to ensure it still aligns with evolving requirements and to tweak Definitions of Done as necessary.



